// vim:set ft=cpp:

#include "adlib/lib.h"
#include "adlib/set.h"
// "fixstr.h" must be included before "map.h"
#include "fixstr.h"
#include "adlib/map.h"

#include "lexer.h"

#script enumnames.tcl

typedef Map<FixStr, Str *> InternMap;

Str *Intern(const char *ptr, Word len) {
  static InternMap *map = NULL;
  if (!map) {
    GCVar(map, new InternMap());
  }
  FixStr fs;
  fs.str = ptr;
  fs.len = len;
  Str *result = map->get(fs, NULL);
  if (!result) {
    result = new Str(ptr, len);
    // `ptr` above is an interior pointer whose contents may disappear
    // due to GC once the `SourceFile` object containing it is no
    // longer reachable.
    //
    // Therefore, we replace it with `result->c_str()`. This is not only
    // not an interior pointer, but is kept alive by the value that the
    // key is in use for.
    fs.str = result->c_str();
    map->add(fs, result);
  }
  return result;
}

#define PUSH_TOKEN(s) \
  token.sym = s; \
  goto pushtoken;

bool ReadSource(SourceFile *source) {
  if (!source->filedata) {
    source->filedata = ReadFile(source->filename);
  }
  return source->filedata != NULL;
}

bool Tokenize(SourceFile *source) {
  Str *input = source->filedata;
  const char *cursor = input->c_str();
  const char *marker = NULL;
  bool done = false;
  bool error = false;
  TokenList *result = new TokenList();
  Token token;
  while (!done) {
    const char *last = cursor;
    /*!re2c
    re2c:define:YYCTYPE = "unsigned char";
    re2c:yyfill:enable = 0;
    re2c:define:YYCURSOR = cursor;
    re2c:define:YYMARKER = marker;

    alpha = [a-zA-Z_];
    digit = [0-9];
    oct = [0-7];
    hex = [0-9a-fA-F];
    floatsuffix = [fFlL]?;
    intsuffix = [uUlL]*;
    exp = 'e' [-+]? digit+;
    squote = ['];
    quote = ["];
    any = [^\000\r\n];
    pparg = any *;
    sp = [ \t\f];
    anystr = any \ ["\\];
    longops = "..." | ">>=" | "<<=" | "+=" | "-=" | "*=" | "/=" | "%="
            | "&=" | "^=" | "|=" | ">>" | "<<" | "++" | "--" | "->"
            | "&&" | "||" | "<=" | ">=" | "==" | "!=";
    esc = "\\" any;

#script rules.tcl
    alpha (alpha | digit)* { PUSH_TOKEN(SymIdent); }
    '0x' hex+ intsuffix { PUSH_TOKEN(SymLiteral); }
    '0' oct+ intsuffix { PUSH_TOKEN(SymLiteral); }
    digit+ intsuffix { PUSH_TOKEN(SymLiteral); }
    "L"? squote (esc any | any) squote { PUSH_TOKEN(SymLiteral); }
    "L"? quote (esc any | anystr)* quote { PUSH_TOKEN(SymLiteral); }
    digit+ exp floatsuffix { PUSH_TOKEN(SymLiteral); }
    digit* "." digit+ exp? floatsuffix { PUSH_TOKEN(SymLiteral); }
    digit+ "." digit* exp? floatsuffix { PUSH_TOKEN(SymLiteral); }
    "(" { PUSH_TOKEN(SymLPar); }
    ")" { PUSH_TOKEN(SymRPar); }
    "[" { PUSH_TOKEN(SymLBrkt); }
    "]" { PUSH_TOKEN(SymRBrkt); }
    "{" { PUSH_TOKEN(SymLBrace); }
    "}" { PUSH_TOKEN(SymRBrace); }
    [-.&!~+*%/<>^|?:=,] { PUSH_TOKEN(SymOp); }
    longops { PUSH_TOKEN(SymOp); }
    ";" { PUSH_TOKEN(SymSemicolon); }
    "//" any+ { PUSH_TOKEN(SymComment); }
    "/" "*" { goto comment; }
    "\r" | "\r\n" | "\n" { PUSH_TOKEN(SymEOL); }
    sp+ { PUSH_TOKEN(SymWS); }
    any { error = true; PUSH_TOKEN(SymBAD); }
    "#" sp "if" sp pparg { PUSH_TOKEN(SymPPCond); }
    "#" sp "ifdef" sp pparg { PUSH_TOKEN(SymPPCond); }
    "#" sp "ifndef" sp pparg { PUSH_TOKEN(SymPPCond); }
    "#" sp "else" sp pparg { PUSH_TOKEN(SymPPCond); }
    "#" sp "elif" sp pparg { PUSH_TOKEN(SymPPCond); }
    "#" sp "endif" sp pparg { PUSH_TOKEN(SymPPCond); }
    "#" sp "define" sp pparg { PUSH_TOKEN(SymPPDef); }
    "#" sp "undefine" sp pparg { PUSH_TOKEN(SymPPDef); }
    "#" pparg { PUSH_TOKEN(SymPPOther); }
    * { done = true; }
    */
    comment:
    /*!re2c
    "*" "/" { PUSH_TOKEN(SymComment); }
    [^\000] { }
    "\000" { done = true; PUSH_TOKEN(SymComment); }
    */
    pushtoken:
      token.str = Intern(last, cursor - last);
      result->add(token);
  }
  token.sym = SymEOF;
  token.str = S("");
  result->add(token);
  source->tokens = result;
  return error;
}
